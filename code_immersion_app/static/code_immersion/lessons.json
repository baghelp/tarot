{"levels": {"beginner": {"abs": "#include <cmath>\n#include <iostream>\n\nint main() {\n  auto result = std::abs(-3.141592f);\n\n  std::cout << result << \"\\n\";\n\n  auto result2 = std::abs(42);\n\n  std::cout << result2 << \"\\n\";\n}\n", "vector_push_back": "#include <vector>\n#include <iostream>\n\nint main() {\n  std::vector<int> v;\n  v.push_back(42);\n\n  std::cout << v.size() << \"\\n\";\n  std::cout << v.back() << \"\\n\";\n}\n", "append_string": "#include <string>\n#include <iostream>\n\nint main() {\n  std::string sentence{\"She\"};\n  sentence.append(\" is playing\");\n  sentence += \" the piano.\";\n\n  std::cout << sentence << \"\\n\";\n}\n", "concatenate_strings": "#include <string>\n#include <iostream>\n\nint main() {\n  std::string subject{\"She\"};\n  std::string verb{\"is playing\"};\n  std::string object{\"the piano\"};\n\n  std::string sentence = subject + \" \" + verb + \" \" + object + \".\";\n\n  std::cout << sentence << \"\\n\";\n}\n", "const": "#include <string>\n#include <iostream>\n\nint main() {\n  const int x = 42;\n  const std::string name = \"Rainier\";\n\n  std::cout << x << \" \" << name << \"\\n\";\n}\n", "constructors": "#include <iostream>\n#include <string>\n\nclass Person {\npublic:\n  int age = 25;\n  std::string name = \"Unknown\";\n};\n\nint main() {\n  // These both call the constructor of Person\n  Person person;\n  Person person2 = Person();\n  std::cout << person.name << \" is \" << person.age << \"\\n\";\n  std::cout << person2.name << \" is \" << person2.age << \"\\n\";\n}\n", "string_to_int": "#include <string>\n#include <iostream>\n\nint main() {\n  std::string s(\"-100\");\n  int i = std::stoi(s);\n  std::cout << i << \"\\n\";\n\n  std::string s2(\"   -2021    \");\n  long l = std::stol(s2);\n  std::cout << l << \"\\n\";\n  \n  std::string s3(\"     1234567890morewords\");\n  unsigned long ll = std::stoul(s3);\n  std::cout << ll << \"\\n\";\n  \n  std::string s4(\"3.1415926535\");\n  float pi = std::stof(s4);\n  std::cout << pi << \"\\n\";\n\n  std::string s5(\"9.10938356e-31kg\");\n  double massOfElectron= std::stof(s5);\n  std::cout << massOfElectron << \"\\n\";\n}\n", "int_to_string": "#include <string>\n#include <iostream>\n\nint main() {\n  int i = -100;\n  std::string s = std::to_string(i);\n  std::cout << s << \"\\n\";\n\n  // We'll lose some precision here\n  float pi = 3.145926535; \n  std::string s2 = std::to_string(pi);\n  std::cout << s2 << \"\\n\";\n}\n", "create_a_file": "#include <fstream>\n\nint main() {\n  std::ofstream output(\"example.txt\");\n  output << \"The answer to life, the universe, and everything is \";\n  output << 42;\n}\n", "variable": "#include <string>\n#include <iostream>\n\nint main() {\n  int x = 5;\n  std::string name = \"Baker\";\n\n  std::cout << x << \" \" << name << \"\\n\";\n  \n  x = 40 + 2;\n  name = \"Rainier\";\n\n  std::cout << x << \" \" << name << \"\\n\";\n}\n", "destructors": "#include <iostream>\n#include <vector>\n\nclass Talker {\npublic:\n  explicit Talker(std::string name) : name_(std::move(name)) {\n    std::cout << name_ << \" here.\\n\";\n  }\n  ~Talker() {\n    std::cout <<  name_ << \", signing off.\\n\";\n  }\nprivate:\n  std::string name_;\n};\n\nint main() {\n  Talker johnny(\"Maria\");\n  {\n    std::vector<Talker> vec; \n    vec.emplace_back(\"Nushi\");\n  }\n  Talker jose(\"Jose\");\n}\n", "exceptions": "#include <exception>\n#include <iostream>\n\nfloat strict_divide(float dividend, float divisor) {\n  if (divisor == 0.0f) {\n    throw std::invalid_argument(\"Cannot divide by zero\");\n  }\n  return dividend / divisor;\n}\n\nint main() {\n  try {\n    strict_divide(42, 0);\n  } catch (const std::invalid_argument& e) {\n    std::cout << e.what() << \"\\n\"; \n  }\n}\n", "for_loop": "#include <iostream>\n#include <vector>\n\nint main() {\n  std::vector numbers{1, 2, 3};\n  for (auto x : numbers) {\n    std::cout << x << \"\\n\";\n  }\n}\n", "functions": "#include <iostream>\n#include <vector>\n\nint add(int a, int b) {\n  return a + b;\n}\n\nfloat average(const std::vector<int>& numbers) {\n  float sum = 0;\n  for (int i : numbers) {\n    sum += i;\n  }\n  return sum / numbers.size();\n}\n\nint main() {\n  int result = add(40, 2);\n  std::cout << result << \"\\n\";\n\n  std::vector numbers{70, 80, 90, 100};\n  float avg = average(numbers);\n  std::cout << avg << \"\\n\";\n}\n", "what_is_the_heap": "#include <iostream>\n\nint main() {\n  int* a = new int(5);\n  std::cout << \"*a: \" << *a << \" a: \" << a << \"\\n\";\n  delete a;\n}\n", "index_array": "#include <array>\n#include <iostream>\n\nint main() {\n  std::array fibonacci{1, 1, 2, 3, 5};\n  std::cout << fibonacci[4] << \"\\n\";\n}\n", "initialize_struct": "#include <string>\n#include <iostream>\n\nstruct Point {\n  float x, y, z;\n};\n\nstruct Person {\n  std::string name;\n  int age;\n  bool married;\n};\n\nint main() {\n  Point origin{0, 0, 0};\n  std::cout << origin.x << \", \" << \n               origin.y << \", \" << \n               origin.z << \"\\n\";\n\n  Point elsewhere{3.0f, 4.0f, 5.0f};\n  std::cout << elsewhere.x << \", \" << \n               elsewhere.y << \", \" << \n               elsewhere.z << \"\\n\";\n\n  Person maria{\"Maria\", 42, true};\n  std::cout << maria.name << \": \" << maria.age << \"\\n\";\n  Person nushi{\"Nushi\", 12, false};\n  std::cout << nushi.name << \": \" << nushi.age << \"\\n\";\n}\n", "start": "int main() {\n  return 0; // success!\n}\n", "member_function": "#include <iostream>\n#include <string>\n\nclass Dog {\npublic:\n  // A member function called \"set_name\"\n  void set_name(std::string name) {\n    // Use `this` to make it clear we're assigning the name field\n    // and not the name parameter\n    this->name = std::move(name);\n  }\n\n  std::string name;\n};\n\nint main() {\n  Dog d;\n  d.set_name(\"Doge\");\n\n  std::cout << d.name << \"\\n\";\n}\n", "namespace_aliases": "#include <iostream>\n\n// Declare our own namespace\nnamespace robs_great_math_library {\n  int add(int a, int b) {\n    return a + b;\n  }\n}\n\n// Create a namespace alias\nnamespace m = robs_great_math_library;\n\nint main() {\n  // Use the namespace alias we created\n  std::cout << m::add(40, 2) << \"\\n\";\n  // We can still use the original name as well\n  std::cout << robs_great_math_library::add(984, 737) << \"\\n\";\n}\n", "namespaces": "#include <iostream>\n\n// Declare our own namespace\nnamespace math {\n  int add(int a, int b) {\n    return a + b;\n  }\n}\n\nint main() {\n  std::cout << math::add(40, 2) << \"\\n\";\n}\n", "nearest_int": "#include <cmath>\n#include <iostream>\n\nint main() {\n  auto ceiling = std::ceil(3.141592f);\n\n  std::cout << ceiling << \"\\n\";\n  \n  ceiling = std::ceil(-3.141592f);\n\n  std::cout << ceiling << \"\\n\";\n}\n", "pass_array_to_function": "#include <array>\n#include <unordered_set>\n#include <iostream>\n\nusing std::unordered_set;\nusing std::array;\n\nunordered_set<int> unique(const array<int, 12>& numbers) {\n  unordered_set<int> uniqueNumbers;\n  for (auto n : numbers) {\n    uniqueNumbers.insert(n);\n  }\n  return uniqueNumbers;\n}\n\nint main() {\n  array numbers{1, 2, 42, 8, 0, -7, 2, 5, 10, 3, -100, 5};\n  auto uniqueNumbers = unique(numbers);\n\n  std::cout << uniqueNumbers.size() << \"\\n\";\n}\n", "pointer": "#include <iostream>\n\nusing std::cout;\n\nint main() {\n  int answer = 42;\n  int* theAddressOfAnswer = &answer;\n\n  cout << \"The answer is: \" << answer << \"\\n\";\n\n  cout << \"The address of answer is: \" \n       << theAddressOfAnswer << \"\\n\";\n  \n  cout << \"The answer (through a pointer) is: \" \n       << *theAddressOfAnswer << \"\\n\";\n}\n", "pointers_vs_references": "#include <iostream>\n\nint multiply_ref(const int& a, const int& b) {\n  return a * b;\n}\n\nint multiply_ptr(const int* const a, const int* const b) {\n  return *a * *b;\n}\n\nint main() {\n  int a = 2;\n  int b = 3;\n\n  std::cout << multiply_ref(a, b) << \"\\n\";\n  std::cout << multiply_ptr(&a, &b) << \"\\n\";\n}\n", "print": "#include <iostream>\n\nint main() {\n    std::cout << \"Hello, World!\\n\";\n}\n", "public_private_protected": "#include <string>\n#include <iostream>\n\nclass Person {\npublic:\n  explicit Person(int age) : age(age) {\n  }\n\n  void happy_birthday() {\n    age += 1;\n    std::cout << \"It's \" << nickname << \"'s birthday.\\n\";\n    std::cout << \"You're \" << age << \". Have anything to say?\\n\";\n    std::cout << \"\\\"\" << catchphrase << \"\\\"\\n\";\n  }\n\n  std::string nickname;\n\nprotected:\n  std::string catchphrase = \"Once more around the Sun.\";\n\nprivate:\n  int age = 25;\n};\n\nclass HappyPerson : public Person {\npublic:\n  explicit HappyPerson(int age) : Person(age) {\n    catchphrase = \"I'm just glad to be here.\";\n  }\n};\n\nint main() {\n  Person p(25);\n  p.nickname = \"Johnny\";\n  p.happy_birthday();\n\n  std::cout << \"\\n\";\n\n  HappyPerson hp(20);\n  hp.nickname = \"Happy Gal\";\n  hp.happy_birthday();\n}\n", "pow": "#include <cmath>\n#include <iostream>\n\nint main() {\n  auto result = std::pow(3, 8);\n\n  std::cout << result << \"\\n\";\n\n  auto result2 = std::pow(3.141592f, 8.3f);\n\n  std::cout << result2 << \"\\n\";\n}\n", "read_a_file": "#include <fstream>\n#include <iostream>\n\nint main() {\n  std::string filename{\"file_with_single_number.txt\"};\n  std::ifstream input{filename};\n\n  if (!input.is_open()) {\n    std::cerr << \"Couldn't read file: \" << filename << \"\\n\";\n    return 1; \n  }\n\n  int number = 0;\n  input >> number;\n  \n  std::cout << \"The number is \" << number << \".\\n\";\n}\n", "recursion": "#include <iostream>\n\n// Calculate the factorial of N, or N!\n// The factorial of N is N * N-1 * N-2 ... * 1\n// 7! = 7 * 6 * 5 * 4 * 3 * 2 * 1\nuint64_t factorial(uint64_t n) {\n  if (n == 0 || n == 1) {\n    return 1;\n  }\n  return n * factorial(n - 1); \n}\n\nint main() {\n  std::cout << factorial(7) << \"\\n\";\n}\n", "mod": "#include <cmath>\n#include <iostream>\n\nint main() {\n  auto result = 23 % 5;\n\n  std::cout << result << \"\\n\";\n\n  auto result2 = std::fmod(23.4f, 5.0f);\n\n  std::cout << result2 << \"\\n\";\n}\n", "what_are_smart_pointers": "#include <iostream>\n#include <memory>\n\nclass Talker {\npublic:\n  explicit Talker(std::string name) : name_(std::move(name)) {\n    std::cout << name_ << \" here.\\n\";\n  }\n  ~Talker() {\n    std::cout <<  name_ << \", signing off.\\n\";\n  }\nprivate:\n  std::string name_;\n};\n\nint main() {\n  Talker* nushi = new Talker(\"Nushi\");\n  \n  // The std::unique_ptr calls delete for us\n  std::unique_ptr<Talker> jose = std::make_unique<Talker>(\"Jose\");\n\n  // We can't forget to call `delete` because we called `new`!\n  delete nushi;\n}\n", "split_string": "#include <string>\n#include <vector>\n#include <iostream>\n\nstd::vector<std::string> split(const std::string& s, char c) {\n  std::vector<std::string> result;\n  size_t begin = 0;\n  while (true) {\n    size_t end = s.find_first_of(c, begin);\n    result.push_back(s.substr(begin, end - begin));\n\n    if (end == std::string::npos) {\n      break;\n    }\n  \n    begin = end + 1;\n  }\n  return result;\n}\n\nint main() {\n  std::string planets{\"Mercury,Venus,Earth,Mars\"};\n  std::cout << planets << \"\\n\";\n  \n  std::cout << \"--- Split on ',' ---\\n\";\n  std::vector<std::string> v = split(planets, ',');\n  for (const auto& s : v) {\n    std::cout << s << \"\\n\";\n  }\n\n  std::cout << \"--- Split on 'u' ---\\n\";\n  v = split(planets, 'u');\n  for (const auto& s : v) {\n    std::cout << s << \"\\n\";\n  }\n\n  std::cout << \"--- Split on 'x' ---\\n\";\n  v = split(planets, 'x');\n  for (const auto& s : v) {\n    std::cout << s << \"\\n\";\n  }\n\n  std::cout << \"--- Split an empty string ---\\n\";\n  v = split(\"\", ',');\n  for (const auto& s : v) {\n    std::cout << s << \"\\n\";\n  }\n}\n", "sqrt": "#include <cmath>\n#include <iostream>\n\nint main() {\n  auto result = sqrt(729);\n\n  std::cout << result << \"\\n\";\n\n  auto result2 = cbrt(729); \n  \n  std::cout << result2 << \"\\n\";\n}\n", "square_a_number": "#include <iostream>\n\nint square(int x) {\n  return x * x;\n}\n\nint main() {\n  int x = 7;\n  std::cout << square(x) << \"\\n\";\n}\n", "what_is_the_stack": "#include <iostream>\n\nvoid foo(int a) {\n  std::cout << \"      foo() Scope\\n\";\n  int b = 4;\n  std::cout << \"      a: \" << a << \", &a: \" << &a << \"\\n\";\n  std::cout << \"      b: \" << a << \", &b: \" << &b << \"\\n\";\n  std::cout << \"      leaving foo() Scope\\n\";\n}\n\nint main() {\n  std::cout << \"Main Scope\\n\";\n  int a = 10;\n  std::cout << \"a: \" << a << \", &a: \" << &a << \"\\n\";\n\n  {\n    std::cout << \"  First Inner Scope\\n\";\n    int b = 20;\n    std::cout << \"  a: \" << a << \", &a: \" << &a << \"\\n\";\n    std::cout << \"  b: \" << b << \", &b: \" << &b << \"\\n\";\n\n    {\n      std::cout << \"    Second Inner Scope\\n\";\n      int c = 30;\n      std::cout << \"    a: \" << a << \", &a: \" << &a << \"\\n\";\n      std::cout << \"    b: \" << b << \", &b: \" << &b << \"\\n\";\n      std::cout << \"    c: \" << a << \", &c: \" << &c << \"\\n\";\n\n      foo(a);\n\n      std::cout << \"    Leaving Second Inner Scope\\n\";\n    }\n      \n    std::cout << \"  a: \" << a << \", &a: \" << &a << \"\\n\";\n    std::cout << \"  b: \" << b << \", &b: \" << &b << \"\\n\";\n    std::cout << \"  Leaving First Inner Scope\\n\";\n  }\n  std::cout << \"a: \" << a << \", &a: \" << &a << \"\\n\";\n  std::cout << \"Leaving Main Scope\\n\";\n}\n", "string_compare": "#include <iostream>\n#include <string>\n\nconst char* as_string(bool b) {\n  return b ? \"true\" : \"false\";\n}\n\nint main() {\n  std::string s{\"Hello cppbyexample.com\"};\n\n  std::cout << as_string(s == \"cppbyexample.com\") << \"\\n\"; \n  std::cout << as_string(s != \"cppbyexample.com\") << \"\\n\"; \n\n  std::string s2{\"Hello cppbyexample.com\"};\n  std::cout << as_string(s == s2) << \"\\n\";\n  std::cout << as_string(s != s2) << \"\\n\";\n}\n", "string_length": "#include <iostream>\n#include <string>\n\nint main() {\n  std::string s{\"Hello cppbyexample.com\"};\n\n  std::cout << s.size() << \"\\n\";\n  std::cout << s.length() << \"\\n\";\n}\n", "substring": "#include <string>\n#include <iostream>\n\nint main() {\n  std::string innerPlanets{\"Mercury Venus Earth Mars\"}; \n\n  // Copy 5 characters from position 8\n  std::cout << innerPlanets.substr(8, 5) << \"\\n\";\n\n  size_t begin = innerPlanets.find(\"Earth\");\n  // Copy characters from \"Earth\" to the end of the string\n  std::cout << innerPlanets.substr(begin);\n}\n", "templates": "#include <iostream>\n\ntemplate <typename T>\nT cube(T x) {\n  return x * x * x;\n}\n\nstruct Point {\n  int x, y, z;\n  \n  friend Point operator *(const Point& a, const Point& b) {\n    return Point{a.x * b.x, a.y * b.y, a.z * b.z};\n  }\n};\n\nint main() {\n  int x = 7;\n  std::cout << cube(x) << \"\\n\";\n\n  float pi = 3.14159f;\n  std::cout << cube(pi) << \"\\n\";\n\n  Point p{1, 2, 3};\n  Point p3 = cube(p);\n  std::cout << p3.x << \", \" << p3.y << \", \" << p3.z << \"\\n\";\n}\n", "ternary_operator": "#include <iostream>\n\nint32_t max(int32_t a, int32_t b) {\n  if (a > b) {\n    return a;\n  } else {\n    return b;\n  }\n}\n\nint32_t max_ternary(int32_t a, int32_t b) {\n  return a > b ? a : b;\n}\n\nint main() {\n  std::cout << max(1, 2) << \"\\n\";\n  std::cout << max(42, 7) << \"\\n\";\n  \n  std::cout << max_ternary(1, 2) << \"\\n\";\n  std::cout << max_ternary(42, 7) << \"\\n\";\n}\n", "trim_whitespace": "#include <string>\n#include <iostream>\n\nstd::string trim(const std::string& s) {\n  // Whitespace is one of: space, tab, carriage return,\n  // line feed, form feed, or vertical tab.\n  const char* whitespace = \" \\t\\n\\r\\f\\v\";\n  size_t begin = s.find_first_not_of(whitespace);\n  if (begin == std::string::npos) {\n    return std::string{};\n  }\n  size_t end = s.find_last_not_of(whitespace);\n  return std::string{s.substr(begin, end - begin + 1)};\n}\n\nint main() {\n  std::string jupiter{\"   Jupiter   \"}; \n  jupiter = trim(jupiter);\n  std::cout << jupiter << \"\\n\";\n\n  std::cout << trim(\" \\t\\n\\r\\f\\v\") << \"\\n\";\n\n  std::string mars = trim(\"\\tMars    \\n\");\n  std::cout << mars << \"\\n\";\n}\n", "what_is_vector": "#include <vector>\n#include <iostream>\n\nint main() {\n  std::vector<int> vec{1, 2, 3};\n  vec.push_back(4);\n\n  std::cout << \"vec.size(): \" << vec.size() << \"\\n\";\n  std::cout << \"vec[1]: \" << vec[1] << \"\\n\";\n\n  vec.pop_back();\n  for (auto n : vec) {\n    std::cout << n << \"\\n\";  \n  }\n}\n", "references": "#include <iostream>\n\nvoid square(int& i) {\n  i = i * i;\n}\n\nint main() {\n  int i = 0;\n  // iAlias is another name for the variable \"i\"\n  int& iAlias = i;\n\n  iAlias = iAlias + 2;\n  std::cout << i << \"\\n\";\n\n  iAlias = iAlias * 6;\n  std::cout << i << \"\\n\";\n\n  square(iAlias);\n  std::cout << i << \"\\n\";\n\n  iAlias = 42; \n  std::cout << i << \"\\n\";\n}\n", "class": "#include <iostream>\n\nstruct Affection {\n  int rubs = 0;\n  int pats = 0;\n  int scritches = 0;\n};\n\nclass Dog {\n  public:\n    void pet(const Affection& affection) {\n      happiness += 1 * affection.rubs;\n      happiness += 2 * affection.pats;\n      happiness += 3 * affection.scritches;\n    }\n\n    void bark() {\n      if (happiness <= 50) {\n        std::cout << \"woof\\n\";\n      } else {\n        std::cout << \"WOOF WOOF!\\n\";\n      }\n    }\n  private:\n    int happiness = 40;\n};\n\nint main() {\n  Dog dog;\n  dog.bark();\n\n  Affection affection;\n  affection.rubs = 2;\n  affection.pats = 4;\n  affection.scritches = 3;\n  dog.pet(affection);\n\n  dog.bark();\n}\n", "size_t": "#include <stddef.h> // size_t\n#include <limits> \n#include <iostream>\n\nint main() {\n  std::cout << std::numeric_limits<size_t>::max() << \"\\n\";\n}\n", "why_pointer": "#include <iostream>\n#include <string>\n\nstruct Planet {\n  std::string name;\n  float distance;\n  float radius;\n  float mass;\n  // We could have lots more here\n};\n\n// We could also accept a \"const Planet&\" here instead\n// https://cppbyexample.com/why_references.html\nvoid describe_planet(Planet* planet) {\n  std::cout << planet->name << \":\\n\"\n            << \"  Distance from Sun: \" << planet->distance << \"\\n\"\n            << \"  Radius: \" << planet->radius << \"\\n\"\n            << \"  Mass: \" << planet->mass << \"\\n\";\n}\n\nint main() {\n  Planet* mars = new Planet{\"Mars\", 1.5, 3389.5, 6.4171e23};\n  if (!mars) {\n    std::cout << \"Unable to allocate memory for a new Planet\\n\";\n    return 1;\n  }\n\n  describe_planet(mars); \n\n  // Everything created with \"new\" must also be \"deleted\"\n  delete mars;\n}\n", "why_references": "#include <iostream>\n#include <string>\n\nstruct Skeleton {\n  std::string name;\n  int bones;\n};\n\nvoid remove_two_bones(Skeleton s) {\n  s.name += \" the Lesser\";\n  s.bones -= 2;\n}\n\nint main() {\n  Skeleton johnny{\"Johnny\", 206};\n  remove_two_bones(johnny);\n  std::cout << johnny.name << \" has \" \n            << johnny.bones << \" bones.\\n\";\n}\n", "what_is_iostream": "#include <iostream>\n\nint main() {\n  std::cout << \"Hello iostream.\\n\";\n}\n", "what_is_shared_ptr": "#include <memory>\n#include <iostream>\n\nstruct Person {\n  Person(std::string name, int age) \n    : name(std::move(name)), age(age) {\n  }\n\n  ~Person() {\n    std::cout << name << \" says bye!\\n\";\n  }\n\n  std::string name;\n  int age;\n};\n\nvoid describe_person(const Person& p) {\n  std::cout << p.name << \" is \" << p.age << \"\\n\";\n}\n\nint main() {\n  // Best to use std::make_shared\n  auto maria = std::make_shared<Person>(\"Maria\", 40); \n  // You can also pass any pointer to std::shared_ptr's constructor\n  Person* p = new Person(\"Nushi\", 12);\n  std::shared_ptr<Person> nushi(p);\n  \n  // shared_ptr can be used just like regular pointers\n  // because of operator overloading\n  describe_person(*maria);\n  describe_person(*nushi);\n\n  nushi->age += 1;\n  describe_person(*nushi);\n}\n", "this": "#include <iostream>\n#include <string>\n\nclass Dog {\npublic:\n  void set_name(std::string name) {\n    // Use `this` to make it clear we're assigning the name field\n    // and not the name parameter\n    this->name = std::move(name);\n  }\n\n  std::string get_name() const {\n    // `this` is implied as \"name\" can only refer to one thing\n    return name; // Identical as \"return this->name;\"\n  }\n\nprivate:\n  std::string name;\n};\n\nint main() {\n  Dog d;\n  d.set_name(\"Doge\");\n\n  std::cout << d.get_name() << \"\\n\";\n}\n", "what_is_unique_ptr": "#include <memory>\n#include <iostream>\n\nstruct Person {\n  Person(std::string name, int age) \n    : name(std::move(name)), age(age) {\n  }\n\n  ~Person() {\n    std::cout << name << \" says bye!\\n\";\n  }\n\n  std::string name;\n  int age;\n};\n\nvoid describe_person(const Person& p) {\n  std::cout << p.name << \" is \" << p.age << \"\\n\";\n}\n\nint main() {\n  // Best to use std::make_unique\n  auto maria = std::make_unique<Person>(\"Maria\", 40); \n  // You can also pass any pointer to std::unique_ptr's constructor\n  Person* p = new Person(\"Nushi\", 12);\n  std::unique_ptr<Person> nushi(p);\n  \n  // unique_ptr can be used just like regular pointers\n  // because of operator overloading\n  describe_person(*maria);\n  describe_person(*nushi);\n\n  nushi->age += 1;\n  describe_person(*nushi);\n}\n"}, "intermediate": {"hash_map_find": "#include <unordered_map>\n#include <string>\n#include <iostream>\n\nint main() {\n  std::unordered_map<int, std::string> statusCodes{\n    {200, \"Success\"},\n    {404, \"This is not the page you're looking for\"},\n  };\n\n  auto it = statusCodes.find(200);\n  if (it != statusCodes.end()) {\n    std::cout << it->first << \": \" << it->second << \"\\n\";\n  } else {\n    std::cout << \"No such status code.\\n\";\n  }\n  \n  it = statusCodes.find(1000);\n  if (it != statusCodes.end()) {\n    std::cout << it->first << \": \" << it->second << \"\\n\";\n  } else {\n    std::cout << \"No such status code.\\n\";\n  }\n}\n", "hash_set_find": "#include <unordered_set>\n#include <string>\n#include <iostream>\n\nint main() {\n  std::unordered_set<std::string> planets{\n    {\"Venus\"},\n    {\"Earth\"},\n    {\"Mars\"},\n  };\n\n  auto it = planets.find(\"Earth\");\n  if (it != planets.end()) {\n    std::cout << *it << \"\\n\";\n  } else {\n    std::cout << \"No such planet.\\n\";\n  }\n  \n  it = planets.find(\"PlanetX\");\n  if (it != planets.end()) {\n    std::cout << *it << \"\\n\";\n  } else {\n    std::cout << \"No such planet.\\n\";\n  }\n}\n", "random_int": "#include <random>\n#include <iostream>\n\nint main() {\n  // 1. The random device\n  std::random_device rd;\n  // 2. The \"Mersenne Twister\" random engine\n  std::mt19937 gen(rd());\n  // 3. A random distribution\n  std::uniform_int_distribution<int> dist(1, 20);\n\n  for (int i = 0; i < 10; i ++) {\n    std::cout << dist(gen) << \" \";\n  }\n  std::cout << \"\\n\";\n}\n", "hash_map": "#include <unordered_map>\n#include <string>\n#include <iostream>\n\nint main() {\n  std::unordered_map<int, std::string> statusMessages{\n    {200, \"Success\"},\n    {404, \"This is not the page you're looking for\"},\n    {403, \"Unauthorized\"},\n    {418, \"I'm a teapot\"},\n  };\n  statusMessages.insert({503, \"Something went wrong\"});\n\n  std::cout << statusMessages[418] << \"\\n\"; \n}\n", "hash_set": "#include <array>\n#include <unordered_set>\n#include <iostream>\n\nint main() {\n  std::array numbers{1, 2, 42, 8, 0, -7, 2, 5, 10, 3, -100, 5};\n\n  std::unordered_set<int> uniqueNumbers;\n  for (auto n : numbers) {\n    uniqueNumbers.insert(n);\n  }\n\n  std::cout << uniqueNumbers.size() << \" unique numbers\\n\";\n}\n", "map": "#include <map>\n#include <string>\n#include <iostream>\n\nint main() {\n  std::map<std::string, int> persons{\n    {\"Maria\", 42},\n    {\"Nushi\", 12},\n    {\"Mohammed\", 25},\n    {\"Jose\", 64}\n  };\n\n  for (const auto& [name, age] : persons) {\n    std::cout << name << \" is \" << age << \" years old.\\n\";\n  }\n}\n", "set": "#include <set>\n#include <string>\n#include <iostream>\n\nint main() {\n  std::set<std::string> tags{\n    {\"wild\"},\n    {\"funny\"},\n    {\"outgoing\"},\n    {\"bashful\"},\n  };\n\n  for (const auto& tag : tags) {\n    std::cout << tag << \"\\n\";\n  }\n}\n", "parse_csv": "name,distance,radius\nMercury,0.4,4879.4\nVenus,0.7,6051.8\nEarth,1.0,6371.0\nMars,1.5,3389.5\nJupiter,5.2,69911\nSaturn,9.5,58232\nUranus,19.2,25362\nNeptune,30.1,24622\n", "print_std_containers": "#include <iostream>\n#include <vector>\n#include <map>\n\nusing std::ostream;\n\ntemplate <typename T>\nostream& operator<<(ostream& o, const std::vector<T>& v) {\n  o << \"[\";\n  if (v.empty()) {\n    o << \"]\";\n    return o;\n  }\n  // For every item except the last write \"Item, \"\n  for (auto it = v.begin(); it != --v.end(); it++) {\n    o << *it << \", \";\n  }\n  // Write out the last item\n  o << v.back() << \"]\";\n  return o;\n}\n\ntemplate <typename KeyT, typename ValueT>\nostream& operator<<(ostream& o, const std::map<KeyT, ValueT>& m) {\n    o << \"{\";\n    if (m.empty()) {\n        o << \"}\";\n        return o;\n    }\n    // For every pair except the last write \"Key: Value, \"\n    for (auto it = m.begin(); it != --m.end(); it++) {\n        const auto& [key, value] = *it;\n        o << key << \": \" << value << \", \";\n    }\n    // Write out the last item\n    const auto& [key, value] = *--m.end();\n    o << key << \": \" << value << \"}\";\n    return o;\n}\n\nint main() {\n    std::vector vec{1.0f, 2.0f, 3.0f};\n    std::cout << vec << \"\\n\";\n\n    std::map<std::string, float> planetDistances {\n        {\"Venus\", 0.723f},\n        {\"Earth\", 1.0f},\n        {\"Mars\", 1.5f},\n    };\n    std::cout << planetDistances << \"\\n\";\n}\n", "sort": "#include <algorithm> // std::sort\n#include <vector>\n#include <iostream>\n\nint main() {\n  std::vector<int> nums{20, 20, 1, 8, 18, 4, 19, 15, 5, 2};\n\n  // Sort a C++ std::vector \n  std::sort(nums.begin(), nums.end());\n  for (const int& n : nums) {\n    std::cout << n << \" \";\n  }\n  std::cout << \"\\n\";\n\n  // Sort a C array\n  int c_array[] = {20, 20, 1, 8, 18, 4, 19, 15, 5, 2};\n  std::sort(std::begin(c_array), std::end(c_array));\n  for (int n : c_array) {\n    std::cout << n << \" \";\n  }\n  std::cout << \"\\n\";\n}\n", "hash_map_custom_types": "#include <unordered_map>\n#include <string>\n#include <iostream>\n\nstruct Planet {\n  std::string name;\n\n  friend bool operator==(const Planet& a, const Planet& b) {\n    return a.name == b.name;\n  }\n};\n\n// Our custom std::hash specialization for Planet\ntemplate <>\nstruct std::hash<Planet> {\n  size_t operator()(const Planet& p) const noexcept {\n    return std::hash<std::string>{}(p.name);\n  }\n};\n\nint main() {\n  std::unordered_map<Planet, std::string> descriptions{\n    {{\"Earth\"}, \"Home\"},\n    {{\"Mars\"}, \"The red planet\"},\n  };\n\n  Planet earth{\"Earth\"};\n  std::cout << descriptions[earth] << \"\\n\"; \n}\n", "hash_set_custom_types": "#include <unordered_set>\n#include <string>\n#include <iostream>\n\nstruct Planet {\n  std::string name;\n\n  friend bool operator==(const Planet& a, const Planet& b) {\n    return a.name == b.name;\n  }\n};\n\n// Our custom std::hash specialization for Planet\ntemplate <>\nstruct std::hash<Planet> {\n  size_t operator()(const Planet& p) const noexcept {\n    return std::hash<std::string>{}(p.name);\n  }\n};\n\nint main() {\n  std::unordered_set<Planet> planets{\n    {{\"Earth\"}},\n    {{\"Mars\"}},\n  };\n\n  Planet jupiter{\"Jupiter\"};\n  std::cout << (planets.count(jupiter) ? \"True\" : \"False\") << \"\\n\"; \n}\n", "lambdas": "#include <iostream>\n\nint main() {\n  auto square = [](int n) { return n * n; };\n\n  int x = square(7);\n\n  std::cout << x << \"\\n\";\n}\n"}, "advanced": {"just_print": "#include <iostream>\n\ntemplate <typename ...Args>\nvoid print(const Args& ...args) {\n  (std::cout << ... << args);\n}\n\nint main() {\n  print(\"Mars is \", 1.5, \"AU from the Sun.\\n\");\n}\n", "vector_reference": "#include <vector>\n#include <iostream>\n\ntemplate <typename ...Args>\nvoid println(const Args& ...args) {\n  (std::cout << ... << args) << \"\\n\";\n}\n\nint main() {\n  std::vector<int> vec;\n  vec.push_back(1);\n  vec.push_back(2);\n\n  println(vec.size());\n  println(vec[0]);\n  println(\"---\");\n\n  println(vec.back());\n  vec.pop_back();\n  println(vec.size());\n  println(\"---\");\n\n  vec[0] = 7;\n  println(vec[0]);\n  println(\"---\");\n\n  vec.insert(vec.end(), {1, 2, 3});\n\n  for (auto x : vec) {\n    println(x);\n  }\n}\n"}}}